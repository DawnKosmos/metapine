// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: 02_ticker_index.sql

package gen

import (
	"context"
)

const createIndex = `-- name: CreateIndex :one
INSERT INTO index (name)
VALUES ($1)
RETURNING index_id
`

func (q *Queries) CreateIndex(ctx context.Context, name string) (int32, error) {
	row := q.db.QueryRow(ctx, createIndex, name)
	var index_id int32
	err := row.Scan(&index_id)
	return index_id, err
}

const createTicker = `-- name: CreateTicker :one
INSERT INTO ticker (exchange, ticker)
VALUES ($1, $2)
RETURNING ticker_id
`

type CreateTickerParams struct {
	Exchange Exchanges
	Ticker   string
}

func (q *Queries) CreateTicker(ctx context.Context, arg CreateTickerParams) (int32, error) {
	row := q.db.QueryRow(ctx, createTicker, arg.Exchange, arg.Ticker)
	var ticker_id int32
	err := row.Scan(&ticker_id)
	return ticker_id, err
}

const createTickerIndex = `-- name: CreateTickerIndex :exec
INSERT INTO ticker_index (ticker_id, index_id, weight, excludevolume)
VALUES ($1, $2, $3, $4)
`

type CreateTickerIndexParams struct {
	TickerID      int32
	IndexID       int32
	Weight        int32
	Excludevolume bool
}

func (q *Queries) CreateTickerIndex(ctx context.Context, arg CreateTickerIndexParams) error {
	_, err := q.db.Exec(ctx, createTickerIndex,
		arg.TickerID,
		arg.IndexID,
		arg.Weight,
		arg.Excludevolume,
	)
	return err
}

const deleteIndex = `-- name: DeleteIndex :exec
DELETE
FROM index
WHERE index_id = $1
`

func (q *Queries) DeleteIndex(ctx context.Context, indexID int32) error {
	_, err := q.db.Exec(ctx, deleteIndex, indexID)
	return err
}

const getIndexIdByName = `-- name: GetIndexIdByName :one
SELECT index_id FROM index
WHERE name = $1
`

func (q *Queries) GetIndexIdByName(ctx context.Context, name string) (int32, error) {
	row := q.db.QueryRow(ctx, getIndexIdByName, name)
	var index_id int32
	err := row.Scan(&index_id)
	return index_id, err
}

const returnIndex = `-- name: ReturnIndex :many
SELECT index.name, ticker.exchange, ticker.ticker, ticker_index.weight, ticker_index.excludevolume
FROM ticker_index
         JOIN ticker ON ticker.ticker_id = ticker_index.ticker_id
         JOIN index ON index.index_id = ticker_index.index_id
WHERE index.index_id = $1
`

type ReturnIndexRow struct {
	Name          string
	Exchange      Exchanges
	Ticker        string
	Weight        int32
	Excludevolume bool
}

func (q *Queries) ReturnIndex(ctx context.Context, indexID int32) ([]ReturnIndexRow, error) {
	rows, err := q.db.Query(ctx, returnIndex, indexID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReturnIndexRow
	for rows.Next() {
		var i ReturnIndexRow
		if err := rows.Scan(
			&i.Name,
			&i.Exchange,
			&i.Ticker,
			&i.Weight,
			&i.Excludevolume,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const returnIndexList = `-- name: ReturnIndexList :many
SELECT index.index_id, index.name, count(index_id) composite_of
FROM index
         JOIN ticker_index ON index.index_id = ticker_index.index_id
GROUP BY index.index_id
HAVING COUNT(index.index_id) >= 2
ORDER BY index.name
`

type ReturnIndexListRow struct {
	IndexID     int32
	Name        string
	CompositeOf int64
}

func (q *Queries) ReturnIndexList(ctx context.Context) ([]ReturnIndexListRow, error) {
	rows, err := q.db.Query(ctx, returnIndexList)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReturnIndexListRow
	for rows.Next() {
		var i ReturnIndexListRow
		if err := rows.Scan(&i.IndexID, &i.Name, &i.CompositeOf); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
